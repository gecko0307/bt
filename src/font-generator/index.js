const fs = require("fs-extra");  
const util = require("util");
const path = require("path");
const unixify = require("unixify");
const glob = require("glob-promise");
const template = require("es6-template-strings");
const compile = require("es6-template-strings/compile");
const resolveToString = require("es6-template-strings/resolve-to-string");

function requireUncached(module) {
    delete require.cache[require.resolve(module)];
    return require(module);
}

// TODO: update to work with Banny Tools projects

const defaultTemplate = "font.template.css";
const defaultWhitelist = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890.,:;!?-+*/=><@#ï¿½$%^&()[]{}|";

function processFont(fontsDir, configDir, font) {
    const fontFamily = font.family || "";
    const fontFile = path.join(fontsDir, font.file || "");
    const whitelist = font.whitelist || defaultWhitelist;
    const cssTemplateFilename = path.join(configDir, font.cssTemplate || defaultTemplate);
    
    console.log(whitelist);

    function strToHex(str) {
        let result = "";
        for (let i = 0; i < str.length; i++) {
            result += "U+" + str.charCodeAt(i).toString(16) + ",";
        }
        return result;
    }

    const glyphhanger = "glyphhanger";
    const commandTemplate = "%s --whitelist=%s --formats=woff --subset=%s";
    const cssTemplate = compile(fs.readFileSync(cssTemplateFilename, "utf8"));
    const command = util.format(commandTemplate, glyphhanger, strToHex(whitelist), fontFile);

    console.log(command);

    require("child_process").execSync(command, function(err, stdout, stderr) {
        if (err) {
            return console.log(err);
        }
    });
    
    var woffFile = util.format(path.join(fontsDir, "%s-subset.woff"), path.parse(fontFile).name);
    var woffData = fs.readFileSync(woffFile);
    var woffDataBase64 = woffData.toString("base64");
    var css = resolveToString(cssTemplate, {font_family: fontFamily, font_data: woffDataBase64});
    
    return css;
}

const comment = "/* Generated by webfontgen.js */\n";

function generateFonts() {
    const fonts = requireUncached(path.resolve("./src/fonts.json"));
    const fontsDir = path.resolve("./fonts");
    const configDir = path.resolve("./src");
    const outputDir = path.resolve("./");
            
    var css = comment;
    Object.keys(fonts).forEach(function(key) {
        css += processFont(fontsDir, configDir, fonts[key]);
    });

    fs.writeFile(path.join(outputDir, "fonts.css"), css, function(err) {
        if (err)
            return console.log(err);
        else
            console.log("Success!");
    });
}

//

async function fontsList(req) {
    const fontsDir = unixify(path.resolve("./Fonts"));
    const pattern = `${fontsDir}/**/*.{ttf,otf}`;
    const files = await glob.promise(pattern);
    return {
        ok: true,
        message: "",
        data: {
            fonts: files.map((file) => path.basename(file))
        }
    };
}

async function fontsConfig(req) {
    const configPath = path.resolve("./.data/fonts.config.json");
    if (await fs.existsSync(configPath) === true) {
        const config = requireUncached(configPath);
        return {
            ok: true,
            message: "",
            data: {
                config: config
            }
        };
    }
    else {
        return {
            ok: false,
            message: ".data/fonts.config.json not found"
        };
    }
}

async function generateFonts(req) {
    const config = req.config;
    console.log(req);
    return {};
}

module.exports = {
    fontsList,
    fontsConfig,
    generateFonts
};
